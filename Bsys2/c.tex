\subsection{Toolchain}
\textbf{Präprozessor: }entfernt Kommentare, ersetzt Makros\\
%\prgc{#define struct } definiert ein Makro\\
%\prgc{#if #else/elif #endif} je nach Bedingung wird Text inkl.\\
%\prgc{#include <header.h>} kopiert gesamten Inhalt an Stelle\\
%\prgc{<file.h>} nur im Systemverzeichnis geschaut, \prgc{"file.h"} Systemverz. + aktuellem\\
\textit{Output: reine C-Datei/Translation-Unit}\\
\textbf{Compiler: }übersetzt Translation-Unit nach Assemble
\textit{Output: Assembly file}
\textbf{Assembler: }übersetzt Text-Assembler in Binärdatei
\textbf{Linker: }Auflösung von Referenzen
\textit{Output: Bibliotheken (statisch/dynamisch), Executable}
\textbf{Loader: }lädt Executables \& dynamische Bibliotheken in Hauptspeicher (statische vorher mit Executable/dynamischer verknüpft)
%\subsubsection{Basistypen}\\
%\begin{tabular}{ll}
%\prgc{char}                     & mind. 8 Bit\\
%\prgc{[signed] short [int]}     & mind. 16 Bit\\
%\prgc{[signed] int}             & mind. 16 Bit\\
%\prgc{[signed] long [int]}      & mind. 32 Bit\\
%\prgc{[signed] long long [int]} & mind. 64 Bit
%\end{tabular}\\
%default-mässig alle Basistypen signed


%\subsubsection{Pointer generell}\\
%Testen auf Nullpointer: \prgc{if (!px)} $\leftrightarrow$ \prgc{if(px == 0)}\\
%\prgc{void *} implizite Konvertierung in beide Richtung (kein Casting nötig)

%\subsubsection{Array}\\
%\prgc{a[b]} $\leftrightarrow$ \prgc{*(a + sizeof(T) * b)}\\
%\prgc{int *p1 = a;}/\prgc{= &a[0];} $\rightarrow$ \prgc{p1[2] = ..;} möglich

%\subsubsection{Funktionspointer}
%\begin{minted}{C}
%int (*bez) (int, int) = &f;
%p = g; //andere Funktion zuweisen
%int i = (*bez) (1,2);
%int j = bez (3,4); //Alternativer Aufruf
%\end{minted}
%\prgc{typedef void (*button_event_handler)(..)}

%\subsubsection{Structs}
%\begin{minted}{C}
%struct T //Tag für Wiederverwendung
%{int x; int y;};
%struct T t = {.x = 5, .y = 7}; //Initalisierung
%\end{minted}
%Verwendung mit \prgc{typedef}: \prgc{typedef struct {..} T;} $\rightarrow$ \prgc{T t;}\\
%belegt gleichen Speicherplatz wie \prgc{int x; int y;}einzeln\\
%Zugriff: \prgc{t.x = t.y}\\
%\prgc{x} gleiche Adresse wie Struct\\
%Member müssen im Speicher nicht dicht liegen (Padding möglich)\\
%\textbf{Pointer auf Structs: }\prgc{struct T* z; t->x = t->y;}\\